#' Accessing contents of the multiverse object
#'
#' @description A multiverse object contains several \strong{Object variables}. These can be accessed using convenient functions.
#' Variables from the analysis that is being performed within the multiverse can be accessed using the \code{$}.
#' Object variables such as the \code{code}, the \code{expanded parameter options table}, the \code{parameters} and the \code{conditions} can be accessed using respective functions

#' @name accessors
#' @param multiverse Object of class multiverse
#' @param name a variable name
#' @param value a new value to be assigned
#'
#'@importFrom dplyr select
#'
#' @export
`$.multiverse` <- function(multiverse, name) {
  .idx = 1
  m_obj = attr(multiverse, "multiverse")
  .env <- unlist(unname(tail(attr(multiverse, "multiverse")$multiverse_diction$as_list(), n = 1)), recursive = FALSE)[[1]]$env

  get(as.character(name), .env)
}

#' @rdname accessors
#' @export
`$<-.multiverse` <- function(multiverse, name, value) {
  stop(
    "cannot assign to objects in the multiverse. 
    The `$` can only be used to extract objects from the default analysis of the multiverse"
  )
}

#' @rdname accessors
#' @export
expand <- function(multiverse) {
  UseMethod("expand")
}

#' @rdname accessors
#' @export
expand.default <- function(multiverse) {
  stop(
    "Objects of type ", deparse(class(multiverse)), " do not have method `expand`. \n",
    "Please use objects of type `multiverse."
  )
}

#' @rdname accessors
#' @export
expand.multiverse <- function(multiverse) {
  .m_obj = attr(multiverse, "multiverse")
  .m_list = .m_obj$multiverse_diction$as_list()
  
  # asserting this is only one entry
  stopifnot(length(.m_list) == 1)
  .entry_name <- names(.m_list)
  
  n <- length(.m_list[[.entry_name]])
  
  tibble(
    .universe = seq_len(n),
    param.assign = lapply(seq_len(n), function(i) {.m_list[[.entry_name]][[i]][["parameter_assignment"]]}),
    .parameter_assignment = lapply(seq_len(n), function(i) {.m_list[[.entry_name]][[i]][["parameter_assignment"]]}),
    .code = lapply(seq_len(n), get_code_universe, .m_list = .m_list, .level = length(.m_list)),
    .results = lapply( unlist(unname(tail(.m_list, n = 1)), recursive = FALSE), `[[`, "env" )
  ) %>%
    unnest_wider(param.assign)
}


#' @rdname accessors
#' @export
size <- function(multiverse) {
  UseMethod("size")
}

#' @rdname accessors
#' @export
size.default <- function(multiverse) {
  stop(
    "Objects of type ", deparse(class(multiverse)), " do not have method `size`. \n",
    "Please use objects of type `multiverse."
  )
}

#' @rdname accessors
#' @export
size.multiverse <- function(multiverse) {
  nrow(expand(multiverse))
}


#' @rdname accessors
#' @export
code <- function(multiverse) {
  UseMethod("code")
}

#' @rdname accessors
#' @export
code.default <- function(multiverse) {
  stop(
    "Objects of type ", deparse(class(multiverse)), " do not have method `code`. \n",
    "Please use objects of type `multiverse."
  )
}

#' @rdname accessors
#' @export
code.multiverse <- function(multiverse) {
  attr(multiverse, "multiverse")[['code']]
}

#' @rdname accessors
#' @export
parameters <- function(multiverse) {
  UseMethod("parameters")
}

#' @rdname accessors
#' @export
parameters.default <- function(multiverse) {
  stop(
    "Objects of type ", deparse(class(multiverse)), " do not have method `parameters`. \n",
    "Please use objects of type `multiverse`."
  )
}

#' @rdname accessors
#' @export
parameters.multiverse <- function(multiverse) {
  attr(multiverse, "multiverse")[['parameters']]
}

#' @rdname accessors
#' @export
conditions <- function(multiverse) {
  UseMethod("conditions")
}

#' @rdname accessors
#' @export
conditions.default <- function(multiverse) {
  stop(
    "Objects of type ", deparse(class(multiverse)), " do not have method `conditions`. \n",
    "Please use objects of type `multiverse`."
  )
}

#' @rdname accessors
#' @export
conditions.multiverse <- function(multiverse) {
  attr(multiverse, "multiverse")[['conditions']]
}


#' @rdname accessors
#' @param idx index of the universe in the multiverse (corresponds to the row in the table)
#' @export
extract_variable_from_universe <- function(multiverse, idx, name) {
  name = enquo(name)
  stopifnot( is.multiverse(multiverse) )
  m_diction = attr(multiverse, "multiverse")$multiverse_diction
  env_list <- lapply(m_diction$get(unlist(tail(m_diction$keys(), n = 1))), `[[`, "env")
  
  #m_tbl$.results[[idx]][[quo_text(name)]]
  get(quo_text(name), env_list[[idx]])
}


